
[Serializable]
public class MyObject {
  public int n1 = 0;
  public int n2 = 0;
  public String str = null;
}


MyObject obj = new MyObject();
obj.n1 = 1;
obj.n2 = 24;
obj.str = "一些字符串";
IFormatter formatter = new BinaryFormatter();
Stream stream = new FileStream("MyFile.bin", FileMode.Create, FileAccess.Write, FileShare.None);
formatter.Serialize(stream, obj);
stream.Close();



















什么是序列化?
---.net的运行时环境用来支持用户定义类型的流化的机制。它是将对象实例的状态存储到存储媒体的过程。在此过程中，先将对象的公共字段和私有字段以及类的名称（包括类所在的程序集）转换为字节流，然后再把字节流写入数据流。在随后对对象进行反序列化时，将创建出与原对象完全相同的副本。

序列化的目的:
1、以某种存储形式使自定义对象持久化；
2、将对象从一个地方传递到另一个地方。

实质上序列化机制是将类的值转化为一个一般的（即连续的）字节流，然后就可以将该流写到磁盘文件或任何其他流化目标上。而要想实际的写出这个流，就要使用那些实现了IFormatter接口的类里的Serialize和Deserialize方法。
在.net框架里提供了这样两个类：

一、BinaryFormatter

BinaryFormatter使用二进制格式化程序进行序列化。您只需创建一个要使用的流和格式化程序的实例，然后调用格式化程序的 Serialize 方法。流和要序列化的对象实例作为参数提供给此调用。类中的所有成员变量（甚至标记为 private 的变量）都将被序列化。

首先我们创建一个类：
[Serializable]
public class MyObject {
  public int n1 = 0;
  public int n2 = 0;
  public String str = null;
}
Serializable属性用来明确表示该类可以被序列化。同样的，我们可以用NonSerializable属性用来明确表示类不能被序列化。
接着我们创建一个该类的实例，然后序列化，并存到文件里持久：
MyObject obj = new MyObject();
obj.n1 = 1;
obj.n2 = 24;
obj.str = "一些字符串";
IFormatter formatter = new BinaryFormatter();
Stream stream = new FileStream("MyFile.bin", FileMode.Create, 
FileAccess.Write, FileShare.None);
formatter.Serialize(stream, obj);
stream.Close();

而将对象还原到它以前的状态也非常容易。首先，创建格式化程序和流以进行读取，然后让格式化程序对对象进行反序列化。
IFormatter formatter = new BinaryFormatter();
Stream stream = new FileStream("MyFile.bin", FileMode.Open, 
FileAccess.Read, FileShare.Read);
MyObject obj = (MyObject) formatter.Deserialize(fromStream);
stream.Close();

// 下面是证明
Console.WriteLine("n1: {0}", obj.n1);
Console.WriteLine("n2: {0}", obj.n2);
Console.WriteLine("str: {0}", obj.str);

二、SoapFormatter

前面我们用BinaryFormatter以二进制格式来序列化。很容易的我们就能把前面的例子改为用SoapFormatter的，这样将以xml格式化，因此能有更好的可移植性。所要做的更改只是将以上代码中的格式化程序换成 SoapFormatter，而 Serialize 和 Deserialize 调用不变。对于上面使用的示例，该格式化程序将生成以下结果。

<SOAP-ENV:Envelope
  xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance
  xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
  xmlns:SOAP- ENC=http://schemas.xmlsoap.org/soap/encoding/
  xmlns:SOAP- ENV=http://schemas.xmlsoap.org/soap/envelope/
  SOAP-ENV:encodingStyle=
  "http://schemas.microsoft.com/soap/encoding/clr/1.0
  http://schemas.xmlsoap.org/soap/encoding/"
  xmlns:a1="http://schemas.microsoft.com/clr/assem/ToFile">

  <SOAP-ENV:Body>
    <a1:MyObject id="ref-1">
      <n1>1</n1>
      <n2>24</n2>
      <str id="ref-3">一些字符串</str>
    </a1:MyObject>
  </SOAP-ENV:Body>
</SOAP-ENV:Envelope>

在这里需要注意的是，无法继承 Serializable 属性。如果从 MyObject 派生出一个新的类，则这个新的类也必须使用该属性进行标记，否则将无法序列化。例如，如果试图序列化以下类实例，将会显示一个 SerializationException，说明 MyStuff 类型未标记为可序列化。

public class MyStuff : MyObject 
{
  public int n3;
}

然而关于格式化器，还有个问题，假设我们只需要xml，但不需要soap特有的额外信息，那么该怎么做？有两个方案：1、编写一个实现IFormatter接口的类，采用的方式类似于SoapFormatter，但是可以没有你不需要的信息；2、使用框架提供的类XmlSerializer。
XmlSerializer类和前两个主流的序列化类的几个不同点是：
1、不需要Serializable属性，Serializable和NonSerializable属性将会被忽略，但是使用XmlIgnore属性，和NonSerializable属性类似。
2、该类不能安全地访问私有变成员，所以学要将私有成员改为公共成员，或者提供合适的公共特性。
3、要求被序列化的类要有一个默认的构造器。

我们改一下前面的MyObject类为：

public class MyObject {
  public int n1;
  public String str;
  public MyObject(){}
  public MyObject(n1,str)
  {
 this.n1=n1;
 this.str=str;
  }
  public override string ToString()
  {
 return String.Format("{0}:{1}",this.str,this.n1);
  }
}

现在我们用XmlSerializer类来对修改后的MyObject进行序列化。因为XmlSerializer类的构造器里有个Type参数，所以XmlSerializer对象被明确的 连到该Type参数所表示的类了。XmlSerializer类也有Serialize和Deserialize方法：
MyObject obj = new MyObject(12,"some string...");
XmlSerializer formatter = new XmlSerializer(typeof(MyObject));
Stream stream = new FileStream("MyFile.xml", FileMode.Create, 
FileAccess.Write, FileShare.None);
formatter.Serialize(stream, obj);
//下面是反序列化
stream.Seek(0,SeekOrigin.Begin)
MyObject obj_out=(MyObject)formatter.Deserialize(stream)
stream.Close();
Console.WriteLine(obj_out);

这个简单的列子可以加以扩展，以便利用更多的XmlSerializer功能，包括使用属性控制xml标记、使用xml模式和进行soap编码。

自定义序列化

如果你希望让用户对类实现序列化，但是对数据流的组织方式不完全满意，那么可以通过在对象上实现 ISerializable 接口来自定义序列化过程。这一功能在反序列化后成员变量的值失效时尤其有用，但是需要为变量提供值以重建对象的完整状态。除了必须将类申明为 Serializable 的同时，还要要实现 ISerializable接口，需要实现 GetObjectData 方法以及一个特殊的构造函数，在反序列化对象时要用到此构造函数。在实现 GetObjectData 方法时，最常调用的SerializationInfo的方法是AddValue，这个方法具有针对所有标准类型（int、char等等）的重载版本；而 StreamingContext 参数描述给定的序列化流的源和目标，这样我们就可以知道我们是将对象序列化到持久性存储还是在将他们跨进程或机器序列化。而在反序列化时，我们调用SerializationInfo提供的一组Getxxx方法，他们针对所有标准类型数据执行各种AddValue重载版本的逆操作。下代码示例说明了如何在前一部分中提到的 MyObject 类上实现 ISerializable。

[Serializable]
public class MyObject : ISerializable 
{
  public int n1;
  public int n2;
  public String str;

  public MyObject()
  {
  }

  protected MyObject(SerializationInfo info, StreamingContext context)
  {
    n1 = info.GetInt32("i");
    n2 = info.GetInt32("j");
    str = info.GetString("k");
  }

  public virtual void GetObjectData(SerializationInfo info, 
StreamingContext context)
  {
    info.AddValue("i", n1);
    info.AddValue("j", n2);
    info.AddValue("k", str);
  }
}
在序列化过程中调用 GetObjectData 时，需要填充方法调用中提供的 SerializationInfo 对象。只需按名称/值对的形式添加将要序列化的变量。其名称可以是任何文本。只要已序列化的数据足以在反序列化过程中还原对象，便可以自由选择添加至 SerializationInfo 的成员变量。如果基对象实现了 ISerializable，则派生类应调用其基对象的 GetObjectData 方法。

需要强调的是，将 ISerializable 添加至某个类时，需要同时实现 GetObjectData 以及特殊的具有特定原型的构造函数－－重要的是，该构造函数的参数列表必须与GetObjectData相同，这个构造函数将会在反序列化的过程中使用：格式化器从流中反序列化数据，然后通过这个构造函数对对象进行实列化。如果缺少 GetObjectData，编译器将发出警告。但是，由于无法强制实现构造函数，所以，缺少构造函数时不会发出警告。如果在没有构造函数的情况下尝试反序列化某个类，将会出现异常。在消除潜在安全性和版本控制问题等方面，当前设计优于 SetObjectData 方法。例如，如果将 SetObjectData 方法定义为某个接口的一部分，则此方法必须是公共方法，这使得用户不得不编写代码来防止多次调用 SetObjectData 方法。可以想象，如果某个对象正在执行某些操作，而某个恶意应用程序却调用此对象的 SetObjectData 方法，将会引起一些潜在的麻烦。

在反序列化过程中，使用出于此目的而提供的构造函数将 SerializationInfo 传递给类。对象反序列化时，对构造函数的任何可见性约束都将被忽略，因此，可以将类标记为 public、protected、internal 或 private。一个不错的办法是，在类未封装的情况下，将构造函数标记为 protect。如果类已封装，则应标记为 private。要还原对象的状态，只需使用序列化时采用的名称，从 SerializationInfo 中检索变量的值。如果基类实现了 ISerializable，则应调用基类的构造函数，以使基础对象可以还原其变量。

如果从实现了 ISerializable 的类派生出一个新的类，则只要新的类中含有任何需要序列化的变量，就必须同时实现构造函数以及 GetObjectData 方法。以下代码片段显示了如何使用上文所示的 MyObject 类来完成此操作。

[Serializable]
public class ObjectTwo : MyObject
{
  public int num;

  public ObjectTwo() : base(){  }

  protected ObjectTwo(SerializationInfo si, StreamingContext context) : base(si,context)
  {
    num = si.GetInt32("num");
  }

  public override void GetObjectData(SerializationInfo si, StreamingContext context)
  {
    base.GetObjectData(si,context);
    si.AddValue("num", num);
  }
}
切记要在反序列化构造函数中调用基类，否则，将永远不会调用基类上的构造函数，并且在反序列化后也无法构建完整的对象。

对象被彻底重新构建，但是在反系列化过程中调用方法可能会带来不良的副作用,因为被调用的方法可能引用了在调用时尚未反序列化的对象引用。如果正在进行反序列化的类实现了 IDeserializationCallback，则反序列化整个对象图表后，将自动调用 OnSerialization 方法。此时，引用的所有子对象均已完全还原。有些类不使用上述事件侦听器，很难对它们进行反序列化，散列表便是一个典型的例子。在反序列化过程中检索关键字/值对非常容易，但是，由于无法保证从散列表派生出的类已反序列化，所以把这些对象添加回散列表时会出现一些问题。因此，建议目前不要在散列表上调用方法。

 

 

补充：

 


自定义序列化、反序列化有两点要求：

类要实现System.Runtime.Serialization 命名空间的 ISerializable 接口（当然要有[Serializable]属性）。 
类要实现两个方法：
一、ISerializable 接口的 void GetObjectData(SerializationInfo info, StreamingContext context). 
二、要实现一个构造函数 pubic classname(Serializationinfo info, StreamingContext context). 
  下面主要说明以上两个方法的作用以及给出示例代码：

        void GetObjectData(Serializationinfo info, StreamContext context ) 是用来处理要进行序列化的成员，其中info 参数提供各个成员字段信息，可在此时对对象中的成员赋值,调用AddValue()方法。

       构造函数是在反序列化时自动调用, 并利用info.GetStirng(GetDecimal )等函数获取值。

  自定义类：

[Serializable]
public class Fruit : ISerializable
...{
    private string _code;
    private string _name;

    public string Code
    ...{
        get ...{ return _code; }
        set ...{ _code = value; }
    }
    public string Name
    ...{
        get ...{ return _name; }
        set ...{ _name = value; }
    }
    public Fruit()
    ...{ }

    public Fruit(string code, string name)
    ...{
        this._code = code;
        this._name = name;
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    ...{
        info.AddValue("aname", this._name);
        info.AddValue("acode", this._code);
    }

    public Fruit(SerializationInfo info, StreamingContext context)
    ...{
        this.Name = info.GetString("aname");
        this.Code = info.GetString("acode");
    }
 实现：

页面加载时序列化到文件

 protected void Page_Load(object sender, EventArgs e)
    ...{
      
        //序列化
        FileStream fs = new FileStream(@"D: fruit.xml", FileMode.OpenOrCreate);
        Fruit fruit = new Fruit("0001", "苹果");
        XmlSerializer xsl = new XmlSerializer(typeof(Fruit));
       
        xsl.Serialize(fs, fruit);
        fs.Close();
    }

点击按钮反序列化为对象

 protected void Button1_Click(object sender, EventArgs e)
    ...{
        //反序列化
        FileStream fs = new FileStream(@"D: ruit.xml", FileMode.OpenOrCreate);
        XmlSerializer xsl = new XmlSerializer(typeof(Fruit));

        Fruit fruit =(Fruit) xsl.Deserialize(fs);
        fs.Close();
        Response.Write(fruit.Code + "," + fruit.Name);
        
    }