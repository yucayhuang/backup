
一、Virtual方法（虚方法）

     virtual 关键字用于在基类中修饰方法。virtual的使用会有两种情况：

     情况1：在基类中定义了virtual方法，但在派生类中没有重写该虚方法。那么在对派生类实例的调用中，该虚方法使用的是基类定义的方法。

     情况2：在基类中定义了virtual方法，然后在派生类中使用override重写该方法。那么在对派生类实例的调用中，该虚方法使用的是派生重写的方法。

二、Abstract方法（抽象方法）
	如果类成员被abstract修饰，则该类前必须添加abstract，因为只有抽象类才可以有抽象方法。
     abstract关键字只能用在抽象类中修饰方法，并且没有具体的实现。抽象方法的实现必须在派生类中使用override关键字来实现。
	2.抽象类不能直接实例化，必须由其派生类实现。

public abstract class Book
{
	public Book()
	{
	}

	public abstract void getPrice(); //抽象方法，不含主体

	public virtual void getName() //虚方法，可覆盖
	{
		Console.WriteLine("this is a test:virtual getName()");
	}

	public void getDate() //一般方法，若在派生类中重写，须使用new关键字
	{
		Console.WriteLine("this is a test: void getDate()");
	}
}

public class JavaBook:Book
{
	public override void getPrice() //实现抽象方法，必须实现
	{
		Console.WriteLine("this is a test:JavaBook override abstract getPrice()");
	}

	public override void getName() //覆盖原方法，不是必须的
	{
		Console.WriteLine("this is a test:JavaBook override virtual getName()");
	}
}




PS:
overrid 与 new 的区别：(与override不同的是，new隐藏父类方法，但不覆盖，当(Parent)child.fun()还是调用父类方法，而override则调用child的)

重载的规则:
父类提供实现，则父类使用virtual关键字
父类不提供实现，则父类自身和相关方法使用abstract关键字，此时子类必须提供实现
子类重载需使用override关键字，如省略当作new（即投影）处理，并且编译器报编译警告
重载时子类方法不能改写返回值类型
子类中可以使用base关键字引用父类的实现

投影的规则:
父类必须提供实现(甚至可以有virtual关键字)
子类应该使用new关键字，如省略也当作new处理，但编译器报编译警告
投影时子类方法可以改写返回值类型
子类中可以使用base关键字引用父类的实现

PS:
接口和抽象类:

最本质的区别：抽象类是一个不完全的类，是对对象的抽象，而接口是一种行为规范。