TCP和UDP的区别

其实就是两种不同的传输方式：tcp需要握手再交流，就是电话机， udp就像留音机bb机，不需要建立连接
所以udp效率更高，tcp安全性更高

每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
tcp还需要listen步骤，udp只需要send










TCP(transport control protocol，传输控制协议)是面向连接的，面向流的，提供高可靠服务。收发两端都要有一一成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法(Nagle算法)，将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样，接收端就难于分辨出来了，必须提供科学的拆包机制。即面向流的通信是无消息保护边界的。

UDP(user datagram protocol，用户数据报协议)是无连接的，面向消息的，提供高效率服务。不会使用块的合并优化算法，由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区)采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头(消息来源地址，端口等信息)，这样对于接收端来说，就容易进行区分处理了。即面向消息的通信是有消息保护边界的。

















TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂，我们这里只做简单、形象的介绍，你只要做到能够理解这个过程即可。我们来看看这三次对话的简单过程：主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数据。 

UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！ 
  UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。比如，我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。例如，在默认状态下，一次“ping”操作发送4个数据包（如图2所示）。大家可以看到，发送的数据包数量是4包，收到的也是4包（因为对方主机收到后会发回一个确认收到的数据包）。这充分说明了UDP协议是面向非连接的协议，没有建立连接的过程。正因为UDP协议没有连接的过程，所以它的通信效果高；但也正因为如此，它的可靠性不如TCP协议高。QQ就使用UDP发消息，因此有时会出现收不到消息的情况。 

tcp协议和udp协议的差别 
             TCP       UDP 
是否连接     面向连接   面向非连接 
传输可靠性     可靠      不可靠 
应用场合    传输大量数据  少量数据 
速度          慢          快
举例说明	银行    windows的ping命令 QQ发消息


















2、为什么UDP有时比TCP更有优势?

    UDP以其简单、传输快的优势，在越来越多场景下取代了TCP,如实时游戏。

    （1）网速的提升给UDP的稳定性提供可靠网络保障，丢包率很低，如果使用应用层重传，能够确保传输的可靠性。
    （2）TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于TCP内置的系统协议栈中，极难对其进行改进。
    采用TCP，一旦发生丢包，TCP会将后续的包缓存起来，等前面的包重传并接收到后再继续发送，延时会越来越大，基于UDP对实时性要求较为严格的情况下，采用自定义重传机制，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成影响。











3. 具体编程：

TCP: 

TCP编程的服务器端一般步骤是： 

　　1、创建一个socket，用函数socket()；     
		SOCKET SocketListen =socket(AF_INET,SOCK_STREAM, IPPROTO_TCP);
　　2、设置socket属性，用函数setsockopt(); * 可选 
　　3、绑定IP地址、端口等信息到socket上，用函数bind(); 
		SOCKET_ERROR = bind(SocketListen,(const sockaddr*)&addr,sizeof(addr))
　　4、开启监听，用函数listen()；                 
		SOCKET_ERROR == listen(SocketListen,2)
　　5、接收客户端上来的连接，用函数accept()；    
		SOCKET SocketWaiter = accept(SocketListen,_Out_ struct sockaddr *addr _Inout_  int *addrlen);
　　6、收发数据，用函数send()和recv()，或者read()和write(); 
　　7、关闭网络连接； 
		closesocket(SocketListen);closesocket(SocketWaiter);
　　8、关闭监听；

TCP编程的客户端一般步骤是： 

　　1、创建一个socket，用函数socket()； 
　　2、设置socket属性，用函数setsockopt();* 可选 
　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选 
　　4、设置要连接的对方的IP地址和端口等属性； 
　　5、连接服务器，用函数connect()； 
　　6、收发数据，用函数send()和recv()，或者read()和write(); 
　　7、关闭网络连接；



UDP:
与之对应的UDP编程步骤要简单许多，分别如下：

UDP编程的服务器端一般步骤是：
　　
1、创建一个socket，用函数socket()；

2、设置socket属性，用函数setsockopt();* 可选
　　
3、绑定IP地址、端口等信息到socket上，用函数bind();
　　
4、循环接收数据，用函数recvfrom();
　　
5、关闭网络连接；


UDP编程的客户端一般步骤是：
　　
1、创建一个socket，用函数socket()；
　　
2、设置socket属性，用函数setsockopt();* 可选
　　
3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选

4、设置对方的IP地址和端口等属性;
　　
5、发送数据，用函数sendto();
　　
6、关闭网络连接；
